type Coordinate;
type Board;

def N : {n:Int | n == 9} = 9;

def C_mk
    (q1x:Int | 0 <= q1x && q1x < N )
    (q1y:Int | 0 <= q1y && q1y < N ) :
    Coordinate { native "(x, y)" }

def C_x (s:Coordinate) : Int { native "s[0]" }
def C_y (s:Coordinate) : Int { native "s[1]" }



def Board_size : (b:Board) -> Int = uninterpreted;

def Board_is_empty (b:Board) : Bool { native "len(b) == 0" }

def Board_head (b:Board | Board_size b > 0) : Coordinate { native "b[0]" }

def Board_tail (b:Board | Board_size b > 0) : {b2:Board | Board_size b2 == (Board_size b - 1)} { native "b[1:]" }


def conflicts (t:Coordinate) (b:Board) : Int {
    if Board_is_empty b
    then 0
    else
        h : Coordinate = Board_head b;
        tl : Board = Board_tail b;
        row : Int = if C_x t == C_x h then 1 else 0;
        col : Int = if C_y t == C_y h then 1 else 0;
        v1: Int = (C_x t) * (C_y h);
        v2: Int = (C_x h) * (C_y t);
        diag : Int = if v1 == v2 then 1 else 0;
        (row + col + diag) + (conflicts t tl)
}

def Board_quality (b:Board) : Int {
    if Board_is_empty b
    then 0
    else
        h = Board_head b;
        tl = Board_tail b;
        (conflicts h tl) + (Board_quality tl)
}


def create_solution
    (q1 : Coordinate)
    (q2 : Coordinate)
    (q3 : Coordinate)
    (q4 : Coordinate)
    (q5 : Coordinate)
    (q6 : Coordinate)
    (q7 : Coordinate)
    (q8 : Coordinate)
    (q9 : Coordinate) :
   {b:Board | Board_size b == N} { native "[q1, q2, q3, q4, q5, q6, q7, q8, q9]" }


@minimize_int(Board_quality nqueens)
@hide(Board_head, Board_tail, conflicts, Board_quality, Board_is_empty, C_x, C_y)
def nqueens : {b:Board | Board_size b == N} = ?hole;

# (((((((((create_solution ((C_mk 0) 4)) ((C_mk 1) 6)) ((C_mk 4) 1)) ((C_mk 0) 6)) ((C_mk 8) 5)) ((C_mk 5) 0)) ((C_mk 2) 2)) ((C_mk 8) 5)) ((C_mk 3) 6))
