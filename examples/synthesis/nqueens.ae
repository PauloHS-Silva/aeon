type Coordinate;
type Board;

def N : {n:Int | n == 3} = 3;

def C_mk :
    (q1x:Int | 0 <= q1x && q1x < N ) ->
    (q1y:Int | 0 <= q1y && q1y < N ) ->
    Coordinate = native "lambda x: lambda y: (x, y)";

def C_x : (s:Coordinate) -> Int = native "lambda s: s[0]";
def C_y : (s:Coordinate) -> Int = native "lambda s: s[1]";



def Board_size : (b:Board) -> Int = uninterpreted;

def Board_is_empty : (b:Board) -> Bool = \b -> native "len(b) == 0";

def Board_head : (b:Board | Board_size b > 0) -> Coordinate = \b -> native "b[0]";

def Board_tail : (b:Board | Board_size b > 0) -> {b2:Board | Board_size b2 == Board_size b - 1} = \b -> native "b[1:]";


def conflicts (t:Coordinate) (b:Board) : Int {
    if Board_is_empty b
    then 0
    else
        h : Coordinate = Board_head b;
        tl : Board = Board_tail b;
        row : Int = if C_x t == C_x h then 1 else 0;
        col : Int = if C_y t == C_y h then 1 else 0;
        v1: Int = (C_x t) * (C_y h);
        v2: Int = (C_x h) * (C_y t);
        diag : Int = if v1 == v2 then 1 else 0;
        (row + col + diag) + (conflicts t tl)
}

def Board_quality (b:Board) : Int {
    if Board_is_empty b
    then 0
    else
        h = Board_head b;
        tl = Board_tail b;
        (conflicts h tl) + (Board_quality tl)
}


def create_solution :
    (q1 : Coordinate) ->
    (q2 : Coordinate) ->
    (q3 : Coordinate) ->
#    (q4 : Coordinate) ->
#    (q5 : Coordinate) ->
#    (q6 : Coordinate) ->
#    (q7 : Coordinate) ->
#    (q8 : Coordinate) ->
#    (q9 : Coordinate) ->
   {b:Board | Board_size b == N} = native "lambda q1: lambda q2: [q1, q2]";


@minimize_int(Board_quality nqueens)
@hide(Board_head, Board_tail)
def nqueens : {b:Board | Board_size b == N} = ?hole;
